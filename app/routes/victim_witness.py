# This file defines the routes for Victim/Witness

from fastapi import APIRouter, HTTPException, Depends
from app.database import get_collection
from app.models.victim_witness import VictimWitnessCreate, VictimWitnessResponse, RiskLevel
from app.auth.oauth import get_current_user
from app.services.id_genarator import victim_witness_generate_id
from datetime import datetime
from pydantic import BaseModel
import logging

router = APIRouter(
    prefix="/victims",
    tags=["Victims/Witnesses"],
    responses={404: {"description": "Not found"}},
)

class RiskLevelUpdate(BaseModel):
    risk_level: RiskLevel

@router.post("/", response_model=VictimWitnessResponse, summary="Add a new victim/witness")
async def add_victim(victim_data: VictimWitnessCreate, current_user: str = Depends(get_current_user)):
    victims_collection = await get_collection("victims")

    victim_dict = victim_data.model_dump()
    victim_dict["created_at"] = datetime.utcnow()
    victim_dict["updated_at"] = datetime.utcnow()
    victim_dict["vic_wit_id"] = await victim_witness_generate_id()  # Generate unique `vic_wit_id`

    result = await victims_collection.insert_one(victim_dict)
    if not result.acknowledged:
        raise HTTPException(status_code=500, detail="Failed to add victim/witness")

    victim_dict["_id"] = str(result.inserted_id)  # Keep the default `_id` generated by MongoDB
    return VictimWitnessResponse(**victim_dict)

@router.get("/{victim_id}", response_model=VictimWitnessResponse, summary="Retrieve victim details", description="Restricted access")
async def get_victim(victim_id: str, current_user: str = Depends(get_current_user)):
    victims_collection = await get_collection("victims")

    victim = await victims_collection.find_one({"vic_wit_id": victim_id})
    if not victim:
        raise HTTPException(status_code=404, detail="Victim not found")

    # Convert `_id` to string
    victim["_id"] = str(victim["_id"])

    return VictimWitnessResponse(**victim)

@router.patch("/{victim_id}", summary="Update risk level")
async def update_risk_level(victim_id: str, risk_data: RiskLevelUpdate, current_user: str = Depends(get_current_user)):
    victims_collection = await get_collection("victims")
    risk_assessments_collection = await get_collection("victim_risk_assessments")

    victim = await victims_collection.find_one({"vic_wit_id": victim_id})
    if not victim:
        raise HTTPException(status_code=404, detail="Victim not found")

    risk_level = risk_data.risk_level

    update_result = await victims_collection.update_one(
        {"vic_wit_id": victim_id},
        {"$set": {"risk_assessment.level": risk_level, "updated_at": datetime.utcnow()}}
    )

    if update_result.modified_count == 0:
        raise HTTPException(status_code=500, detail="Failed to update risk level")

    risk_entry = {
        "victim_id": victim_id,
        "risk_level": risk_level,
        "update_date": datetime.utcnow()
    }
    await risk_assessments_collection.insert_one(risk_entry)

    return {"message": "Risk level updated successfully", "risk_level": risk_level}

@router.get("/case/{case_id}", summary="List victims linked to a case")
async def list_victims_by_case(case_id: str, current_user: str = Depends(get_current_user)):
    cases_collection = await get_collection("cases")
    victims_collection = await get_collection("victims")

    # Find the case using case_id
    case = await cases_collection.find_one({"case_id": case_id})
    if not case:
        raise HTTPException(status_code=404, detail="Case not found")

    # List victims linked to the case
    victims=[]
    # victims = case.get("victims", [])
    for victim_id in case.get("victims", []):
        victim = await victims_collection.find_one({"vic_wit_id": victim_id})
        if victim:
            # Convert `_id` to string
            victim["_id"] = str(victim["_id"])
            victims.append(VictimWitnessResponse(**victim))

    return victims
